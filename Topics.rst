============
 Темы работ
============

..
    Шаблон темы
    ```````````

    *Сложность: ★★★*

    *Требования: владение здравым смыслом и катаной.*

    *Язык программирования: такой или сякой. Рекомендую эдакий.*

    Цель работы и содержание.

Легенда:

★
    для выполнения работы достаточно творческих дней и практики
★★
    придётся потратить часть свободного времени
★★★
    на работу уйдёт всё свободное время, что вы готовы отдать

.. contents::

Юрий Алексеевич Сыровецкий
--------------------------

Выпускник Лицея 2002 года,
работал в Яндекс.Директе над специализированными БД для рекламной статистики,
сейчас в Лаборатории Касперского создаю безопасную ОС
с помощью функционального программирования,
организую встречи любителей ФП и выступаю на них.

Руковожу научными проектами лицеистов с 2012 года.
Мои ученики высупали на конференциях и конкурсах.

Любимые темы — Computer Science, функциональное программирование (ФП),
языки программирования (изучение старых и проектирование новых),
распределённые системы.

Язык программирования *Haskell*,
с которым я имею удовольствие работать уже несколько лет, —
самый интересный представитель мира ФП,
и практически — как средство для построения систем любой сложности,
и теоретически — как полигон для научных изысканий.

Предварительное знакомство с языком Haskell и ФП не требуется,
я всему обучу в процессе.

Некоторые слова в этом тексте могут показаться заумными и страшными,
на самом деле все концепции простые и вполне под силу лицеисту
(или команде лицеистов).

0. Ваше предложение
```````````````````

*Сложность: определяете вы*

*Язык программирования: ∀.*

Спросите у родителей, знакомых,
какие проблемы возникают в их жизни или работе,
и попробуйте придумать им IT-решение.
Включите фантазию на всю катушку, придумывайте что угодно,
я помогу развить то, что реализуемо, и отсечь то, что нереализуемо.

1. Развитие инструментария построения графиков и визуализации для Haskell и IHaskell
````````````````````````````````````````````````````````````````````````````````````

*Сложность: ★★★*

*Требования: интерес к свободному ПО, желание сделать вклад в сообщество.*

*Язык программирования: Haskell*

Они сейчас не дотягивают по возможностям и красоте до *IPython* и *R*,
хотелось бы предоставить возможности учёным и бизнес-аналитикам
инструменты для визуализации данных, в том числе из *Haskell*.

Возможности IHaskell сейчас:

- `неинтерактивные рисунки из геометрических фигур
  <https://begriffs.com/posts/2016-01-20-ihaskell-notebook.html>`_,
- `простые неинтерактивные графики
  <http://indiana.edu/~ppaml/HakaruTutorial.html>`_,
- `функциональная генерация неинтерактивных изображений
  <http://nbviewer.jupyter.org/github/hansroland/FunctionalImages/blob/master/notebooks/FunctionalImages.ipynb>`_.

Возможности IPython (к чему стремимся):

- `интерактивные графики (plot.ly)
  <http://nbviewer.jupyter.org/gist/msund/7ac1203ded66fe8134cc>`_,
- `трёхмерные и сложные графики
  <http://nbviewer.jupyter.org/github/empet/Math/blob/master/DomainColoring.ipynb>`_.

2. Вычислительный кластер по модели MapReduce на базе технологии Cloud Haskell
``````````````````````````````````````````````````````````````````````````````

*Сложность: ★★*

*Требования:
интерес к сетевым технологиям, параллельным и распределённым системам.*

*Язык программирования: Haskell*

Функциональный подход даёт потрясающие возможности
для параллельных вычислений!
*MapReduce* — это простой способ разбить алгоритм на составные части так,
что его можно будет легко масштабировать на любой кластер.

3. Поисковая система по документации и исходному коду для библиотек языка Haskell
`````````````````````````````````````````````````````````````````````````````````

*Сложность: ★★★*

*Требования: интерес к свободному ПО, желание сделать вклад в сообщество.*

*Язык программирования: Haskell*

Альтернатива веб-интерфейсу Hackage.
Существующий интерфейс хаскелльной системы документирования *Haddock*
имеет множество возможностей для улучшения.

Например, можно сделать

a) саджест по имени функции (и оператора),
b) для заданного типа находить его ко- и контравариантные применения,
c) сравнение (diff) программных интерфейсов между версиями пакетов.

Бонус: `[1] <https://github.com/meditans/documentator>`_

4. Статически типизированная командная оболочка
```````````````````````````````````````````````

*Сложность: от ★*

*Требования: знакомство с unix shell.*

*Язык программирования: ∀. Рекомендую Haskell.*

Для обнаружения максимального количества ошибок до запуска программ.
Если можно заставить компьютер проверять,
правильно ли программист вызывает программы и соединяет их в цепочки,
то надо его заставить.

5. Понятный расширяемый язык разметки
`````````````````````````````````````

*Сложность: от ★*

*Требования: знакомство с языками разметки, HTML или ТеХ.*

*Язык программирования: ∀. Рекомендую Haskell.*

Сейчас для разметки текста используется множество машинных языков,
из которых 2 самых широко используемых — это *HTML* и *ТеХ*.

У них есть множество проблем.

HTML имеет очень сложную модель отображения, не имеет средств абстракции,
для оформления элементов HTML был изобретён другой язык — *CSS* —
совершенно не похожий на первый,
а для автоматизации работы с ними притянули третий — *JavaScript* —
не только кардинально отличающийся от первых двух,
но ещё и приносящий огромное множество собственных недостатков.

ТеХ использует вся научная среда,
у него дела получше с отображением на бумаге и экране,
почти хорошо с абстракцией, но он тоже далёк от идеала:
он императивный, требует нескольких проходов,
его синтаксис местами противоречив, местами просто странный.
Для автоматизации в него притащили Lua, не такой ужасный, как JavaScript,
но можно сделать ещё лучше.

Пришло время создать ТеХ двадцать первого века, декларативный,
функциональный язык, хорошо подходящий как для разметки,
так и для написания сценариев.

6. Реализация любого CRDT
`````````````````````````

*Сложность: от ★*

*Требования: любовь к алгебре.*

*Язык программирования: ∀. Рекомендую Haskell.*

*CRDT* (распределённый коммутативный/сходящийся тип) — 
это основа современных распределённых баз данных.
Например, без такой техники невозможно (или очень сложно) написать
даже счётчик лайков под фоточкой в соцсети,
если мы хотим чтобы он был достаточно быстрым и точным.

7. Доказательство теорем на языке программирования
``````````````````````````````````````````````````

*Сложность: от ★*

*Требования: любовь к логике.*

*Язык программирования: Haskell или другой с достаточно сильной системой типов.
Например, Agda и Idris подходят хорошо, С++ и Java подходят слабо,
Python и JavaScipt не подходят вообще.*

Базовая идея тут довольно простая —
программа является доказательством теоремы (изоморфизм Карри — Ховарда).
Тип программы — это, собственно, доказываемое утверждение.
Мы просто формулируем теорему, пишем доказательство, а компьютер проверяет,
правильное ли оно.
`[1] <https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D1%80%D0%B8_%E2%80%94_%D0%A5%D0%BE%D0%B2%D0%B0%D1%80%D0%B4%D0%B0>`_,
`[2] <https://en.wikibooks.org/wiki/Haskell/The_Curry%E2%80%93Howard_isomorphism>`_,
`[3] <http://lpcs.math.msu.su/~krupski/download/coq_pract.pdf>`_,
`[4] <https://github.com/lspitzner/exference>`_

8. Универсальный синтаксис
``````````````````````````

*Сложность: от ★*

*Требования: умение писать простые программы на нескольких
(хотя бы двух) языках программирования.*

*Язык программирования: ∀. Рекомендую Haskell.*

Цель — создать простейший человекочитаемый синтаксис
для построения языков программирования.

Простейший синтаксис для построения языков программирования уже существует —
это язык S-выражений (известный также как «лисп»),
созданный американским информатиком Джоном Маккарти в 50-х годах прошлого века
по мотивам лямбда-исчисления Алонсо Чёрча.
На этом синтаксисе построены конкретные языки программирования
*Common Lisp*, *Scheme*, *Clojure*,
а также он имеет бесконечный потенциал к построению новых языков
и новых абстракций в существующих языках.

Однако, мне он кажется недостаточно человекочитаемым.
В частности, мне не нравятся

- обилие скобок и
- префиксная запись операторов (способствущая умножению скобок).

Есть у меня пара идей, как их побороть.
Я предлагаю ученикам поэкспериментировать на этом поле вместе со мной,
оценить существующие решения, изобрести новые и сравнить их.
