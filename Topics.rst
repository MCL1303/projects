============
 Темы работ
============

.. contents::

Сыровецкий Ю. А.
----------------

Выпускник Лицея 2002 года,
работал в Яндекс.Директе над специализированными БД для рекламной статистики,
сейчас в Лаборатории Касперского создаю безопасную ОС
с помощью функционального программирования,
организую встречи любителей ФП и выступаю на них.

Мои любимые темы — Computer Science, функциональное программирование (ФП),
языки программирования (изучение старых и проектирование новых),
распределённые системы.

Язык программирования *Haskell*,
с которым я имею удовольствие работать уже несколько лет, —
самый интересный представитель мира ФП,
и практически — как средство для построения систем любой сложности,
и теоретически — как полигон для научных изысканий.

Предварительное знакомство с языком Haskell и ФП не требуется,
я всему обучу в процессе.

Некоторые слова в этом тексте могут показаться заумными и страшными,
на самом деле все концепции простые и вполне под силу лицеисту
(или команде лицеистов).

0. Ваше предложение
```````````````````

Спросите у родителей, знакомых,
какие проблемы возникают в их жизни или работе,
и попробуйте придумать им IT-решение.
Включите фантазию на всю катушку, придумывайте что угодно,
я помогу развить то, что реализуемо, и отсечь то, что нереализуемо.

1. Развитие инструментария построения графиков и визуализации для Haskell и IHaskell
````````````````````````````````````````````````````````````````````````````````````

*Язык программирования: Haskell*

Они сейчас не дотягивают по возможностям и красоте до *IPython* и *R*,
хотелось бы предоставить возможности учёным и бизнес-аналитикам
инструменты для визуализации данных, в том числе из *Haskell*.

Возможности IHaskell сейчас:
`[1] <https://begriffs.com/posts/2016-01-20-ihaskell-notebook.html>`_,
`[2] <http://indiana.edu/~ppaml/HakaruTutorial.html>`_,
`[3] <http://nbviewer.jupyter.org/github/hansroland/FunctionalImages/blob/master/notebooks/FunctionalImages.ipynb>`_.

Возможности IPython (к чему стремимся):
`[1] <http://nbviewer.jupyter.org/gist/msund/7ac1203ded66fe8134cc>`_,
`[2] <http://nbviewer.jupyter.org/github/empet/Math/blob/master/DomainColoring.ipynb>`_.

2. Вычислительный кластер по модели MapReduce на базе технологии Cloud Haskell
``````````````````````````````````````````````````````````````````````````````

*Язык программирования: Haskell*

Функциональный подход даёт потрясающие возможности
для параллельных вычислений!
*MapReduce* — это простой способ разбить алгоритм на составные части так,
что его можно будет легко масштабировать на любой кластер.

3. Поисковая система по документации и исходному коду для библиотек языка Haskell
`````````````````````````````````````````````````````````````````````````````````

*Язык программирования: Haskell*

Альтернатива веб-интерфейсу Hackage.
Существующий интерфейс хаскелльной системы документирования *Haddock*
имеет множество возможностей для улучшения.

Например, можно сделать

a) саджест по имени функции (и оператора),
b) для заданного типа находить его ко- и контравариантные применения,
c) сравнение (diff) программных интерфейсов между версиями пакетов.

Бонус: `[1] <https://github.com/meditans/documentator>`_

4. Статически типизированный shell
``````````````````````````````````

*Язык программирования: ∀. Рекомендую Haskell.*

Для обнаружения максимального количества ошибок до запуска программ.
Если можно заставить компьютер проверять,
правильно ли программист вызывает программы и соединяет их в цепочки,
то надо его заставить.

5. Консистентный расширяемый язык разметки
``````````````````````````````````````````

*Язык программирования: ∀. Рекомендую Haskell.*

ТеХ двадцать первого века.
Язык программирования каждый может написать,
а вот такой язык программирования, на котором ещё и тексты можно писать, —
это должно быть поинтереснее.

6. Реализация любого CRDT
`````````````````````````

*Язык программирования: ∀. Рекомендую Haskell.*

*CRDT* (распределённый сходящийся тип) — 
это основа современных распределённых баз данных.
Например, без такой техники невозможно (или очень сложно) написать
даже счётчик лайков под фоточкой в соцсети,
если мы хотим чтобы он был достаточно быстрым и точным.

7. Доказательство теорем на языке программирования
``````````````````````````````````````````````````

*Язык программирования: Haskell или другой с достаточно сильной системой типов.
Например, Agda и Idris подходят хорошо, С++ и Java подходят слабо,
Python и JavaScipt не подходят вообще.*

Базовая идея тут довольно простая —
программа является доказательством теоремы (изоморфизм Карри — Ховарда).
Тип программы — это, собственно, доказываемое утверждение.
Мы просто формулируем теорему, пишем доказательство, а компьютер проверяет,
правильное ли оно.
`[1] <https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%9A%D0%B0%D1%80%D1%80%D0%B8_%E2%80%94_%D0%A5%D0%BE%D0%B2%D0%B0%D1%80%D0%B4%D0%B0>`_,
`[2] <https://en.wikibooks.org/wiki/Haskell/The_Curry%E2%80%93Howard_isomorphism>`_,
`[3] <http://lpcs.math.msu.su/~krupski/download/coq_pract.pdf>`_,
`[4] <https://github.com/lspitzner/exference>`_

8. Универсальный парсер S-выражений
```````````````````````````````````

*Язык программирования: ∀. Рекомендую Haskell.*

C инфиксными операциями и прочими сахарами.
Возможно, удастся приблизить к чему-нибудь, похожему на ML.
